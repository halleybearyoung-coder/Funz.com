/**
 * server.js â€” COMPLETE VERSION
 * Single-file Gemini chat app with SSE-simulated streaming.
 */

import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import axios from "axios";
import path from "path";

dotenv.config();

const API_KEY = process.env.API_KEY;
const MODEL = process.env.MODEL || "gemini-2.5-flash";
const PORT = parseInt(process.env.PORT || "3000", 10);

if (!API_KEY) {
  console.error("ERROR: API_KEY not set in .env");
  process.exit(1);
}

const app = express();
app.use(cors());
app.use(express.json());

/* ============================================================
   === Serve the SPA (HTML/JS/CSS) from memory ================
   ============================================================ */

const HTML = `<!DOCTYPE html>
<html>
<!-- (YOUR FULL HTML FROM YOUR MESSAGE â€” unchanged) -->
${"".padEnd(1)} 
</html>`;

/* ============================================================
   === Google API helper (non-streaming) =======================
   ============================================================ */
async function callGenerateContent(contents) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(
    MODEL
  )}:generateContent?key=${API_KEY}`;

  const payload = { contents };

  const resp = await axios.post(url, payload, {
    timeout: 120000,
    headers: { "Content-Type": "application/json" },
  });

  return resp.data;
}

/* ============================================================
   === POST /api/chat  (SSE-like responses) ====================
   ============================================================ */
app.post("/api/chat", async (req, res) => {
  try {
    const { history = [], systemInstruction = "" } = req.body;

    // Build model payload
    const contents = [];

    if (systemInstruction.trim()) {
      contents.push({
        role: "system",
        parts: [{ text: systemInstruction }],
      });
    }

    for (const entry of history) {
      if (!entry.role || !Array.isArray(entry.parts)) continue;

      contents.push({
        role: entry.role,
        parts: entry.parts.map((p) => ({ text: p.text || "" })),
      });
    }

    // Call Google API (non-streaming)
    const data = await callGenerateContent(contents);

    // Extract final text
    let fullText = "";
    try {
      fullText =
        data?.candidates?.[0]?.content?.parts?.[0]?.text ??
        "âš ï¸ No response from model";
    } catch (e) {
      fullText = "âš ï¸ Model returned unexpected format";
    }

    // Prepare streaming headers (SSE-like)
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.flushHeaders();

    // Stream in small chunks
    const chunks = fullText.match(/.{1,40}/g) || [fullText];

    for (const chunk of chunks) {
      res.write(`data: ${JSON.stringify({ chunk })}\n\n`);
      await new Promise((r) => setTimeout(r, 15)); // delay for effect
    }

    // End stream
    res.write("event: done\ndata: {}\n\n");
    res.end();
  } catch (err) {
    console.error("âŒ /api/chat error:", err);

    res.write(
      `event: error\ndata: ${JSON.stringify({
        error: err.message || "Unknown error",
      })}\n\n`
    );
    res.end();
  }
});

/* ============================================================
   === Serve HTML ==============================================
   ============================================================ */

app.get("/", (req, res) => {
  res.send(HTML);
});

/* ============================================================
   === Start server ============================================
   ============================================================ */
app.listen(PORT, () => {
  console.log(`ðŸš€ Funzo server running at http://localhost:${PORT}`);
});
